#!/usr/bin/env ruby

require 'rubygems'
require 'osc-ruby'
require 'yaml'
require 'trollop'

# address = ARGV[0]
# port = ARGV[1]
# wait = ARGV[2] # wait boolean toggles whether the padded time at the beginning of recorded yml osc action is used
# filename = ARGV[3]
m_time = 0
start_time = 0

# trollop for better options parsing
opts = Trollop::options do
    version "oscplayer 1.0 by Tom Lieber, Mark Cerqueira, Spencer Salazar"
    banner <<-EOS
oscplayer is a utilty that plays back OSC messages.

Usage:
  oscplayer [options]
  
  where [options] are:
EOS
  opt :address, "String specifying the address to send OSC messages", :type => :string
  opt :port, "Integer specifying the port to listen for OSC messages", :type => :int, :default => -1
  opt :filename, "String specifying the filename to write encoded data to", :type => :string
  opt :wait, "Boolean specifying whether the time of the first recorded message should be respected", :default => false
end

# abort if port/address was not sent by user
Trollop::die :port, "must be defined" if opts[:port] < 0 or opts[:port] > 65535
Trollop::die :address, "must be defined" if !opts.has_key?(:address) || opts[:address].nil?

port = opts[:port]
address = opts[:address]
wait = opts[:wait]
filename = opts[:filename]

@client = OSC::Client.new(address, port)
@start = Time.now

# load from stdin if filename is not specified
if filename.nil?
  @messages = YAML.load_stream($stdin)
else
  @messages = YAML.load_stream(File.open(filename))
end

@messages.each_with_index do |message, index|
  # puts "#{message.class} #{message.inspect}"
  # message is actually an array of size 1 that contains our message object at index 0
  m = message[0]
  
  if index == 0
    start_time = m[:time]
  end

  if wait
    m_time = m[:time]
  else
    m_time = m[:time] - start_time
  end

  dt = (@start + m_time) - Time.now
  # dt = (@start + m[:time]) - Time.now

  # sleep if necessary
  puts "sleeping #{dt}" if dt > 0
  sleep(dt) if dt > 0
  puts '' if dt > 0
  
  message = OSC::OSCPacket.messages_from_network(m[:message]).first
  p message
  begin
    @client.send(message)
  rescue
    puts "Error sending message!"
  end
  
  puts ''
end
